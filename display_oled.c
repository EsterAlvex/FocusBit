#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "pico/stdlib.h"
#include "pico/binary_info.h"
#include "hardware/pwm.h"
#include "inc/ssd1306.h"
#include "hardware/i2c.h"
#include "hardware/gpio.h"
#include "hardware/adc.h"

// Definições do FocusBit
#define INITIAL_STUDY_TIME 25 * 60  // 25 minutos em segundos
#define INITIAL_BREAK_TIME 5 * 60   // 5 minutos em segundos
#define BUTTON_1_PIN 5              // Pino do botão A (iniciar/pausar/alternar)
#define BUTTON_2_PIN 6              // Pino do botão B (registrar tarefa)
#define BUZZER_PIN 21               // Pino do buzzer
#define LED_GREEN_PIN 11            // Pino do LED verde
#define LED_BLUE_PIN 12             // Pino do LED azul
#define LED_RED_PIN 13              // Pino do LED vermelho

// Pinos do Joystick
#define JOYSTICK_X_PIN 27
#define JOYSTICK_Y_PIN 26
#define JOYSTICK_BUTTON_PIN 22

// Estados do Joystick
typedef enum {
    JS_NEUTRAL,
    JS_UP,
    JS_DOWN,
    JS_LEFT,
    JS_RIGHT,
    JS_PRESS
} JoystickState;

// Variáveis globais
int tasksCompleted = 0;             // Número de tarefas concluídas
bool isStudying = true;             // Modo atual (estudo/descanso)
bool isRunning = false;             // Estado do temporizador (rodando ou parado)
int timeLeft;                       // Tempo restante
int study_time = INITIAL_STUDY_TIME; // Tempo de estudo ajustável
int break_time = INITIAL_BREAK_TIME; // Tempo de descanso ajustável
bool in_settings = false;           // Modo de configuração ativo
int selected_setting = 0;           // 0: study time, 1: break time

const uint I2C_SDA = 14;
const uint I2C_SCL = 15;

// Bitmap de exemplo (128x64)
const uint8_t bitmap_128x64[] = {
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x87, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0f, 0xfe, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0x1f, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc3, 0x03, 0xfc, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x80, 0x00, 0xf8, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x00, 0x00, 0xfe, 0xff, 0xff,
   0xff, 0xff, 0x3f, 0x00, 0x00, 0xfe, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x20, 0x00, 0xfc, 0xff, 0xff,
   0xff, 0xff, 0x3f, 0xe0, 0xc0, 0xfe, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xfc, 0xe4, 0xfd, 0xff, 0xff,
   0xff, 0xff, 0xbf, 0xf8, 0xfc, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xbf, 0xdf, 0xe1, 0xfd, 0xff, 0xff,
   0xff, 0xff, 0x3f, 0xc7, 0xe0, 0xfd, 0xff, 0xff, 0xff, 0xff, 0x3f, 0xd8, 0xe0, 0xfe, 0xff, 0xff,
   0xff, 0xff, 0x7f, 0x78, 0x01, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xa0, 0xee, 0xfd, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x43, 0xef, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xe1, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xf8, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x03, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x80, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x99, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x99, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x99, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x7f, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xc0, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x9f, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0x9f, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x9f, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0x9f, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x9f, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x5f, 0x80, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x7f, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xe0, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x7f, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0x9f, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x9f, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0x9f, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x9f, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0x9f, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x9f, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xee, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x1f, 0xc0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0xc0, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1f, 0xe0, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x1f, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xcc, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x7f, 0xcc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0x99, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x9f, 0x99, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0x99, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x9f, 0x99, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0x99, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x3f, 0xc6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xc6, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x01, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0x80, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x9f, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0x9f, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x9f, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0x9f, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x1f, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xc0, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x19, 0x80, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x07, 0xe0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x03, 0xe0, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x9f, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0x9f, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0x9f, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0x9f, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff

};

// Função para tocar um som no buzzer usando PWM
void beep(int duration_ms, int frequency_hz) {
    gpio_set_function(BUZZER_PIN, GPIO_FUNC_PWM);
    uint slice_num = pwm_gpio_to_slice_num(BUZZER_PIN);
    uint channel_num = pwm_gpio_to_channel(BUZZER_PIN); 

    pwm_set_clkdiv(slice_num, 1.0f);
    pwm_set_wrap(slice_num, 125000000 / frequency_hz);
    pwm_set_chan_level(slice_num, channel_num, 125000000 / (2 * frequency_hz));

    pwm_set_enabled(slice_num, true);
    sleep_ms(duration_ms);
    pwm_set_enabled(slice_num, false);
    gpio_set_function(BUZZER_PIN, GPIO_FUNC_SIO);
    gpio_put(BUZZER_PIN, 0);
}

// Melodia para o final do tempo de estudo (mais calma)
void play_study_end_melody() {
    int notes[] = {
         523, 587, 659, 698, 784, 880, 988, 1047,  // Escala ascendente
        1047, 988, 880, 784, 698, 659, 587, 523   // Escala descendente
    };
    int durations[] = {
        400, 400, 400, 400, 400, 400, 400, 800,   // Ritmo constante
        800, 400, 400, 400, 400, 400, 400, 800    // Ritmo constante
    };

    for (int i = 0; i < sizeof(notes) / sizeof(notes[0]); i++) {
        beep(durations[i], notes[i]);
        sleep_ms(50);  // Pequena pausa entre as notas
    }
}

// Melodia para o final do tempo de descanso (mais animada)
void play_break_end_melody() {
    int notes[] = {
        523, 587, 659, 698, 784, 880, 988, 1047,  // Escala ascendente
        1047, 988, 880, 784, 698, 659, 587, 523   // Escala descendente
    };
    int durations[] = {
        400, 400, 400, 400, 400, 400, 400, 800,   // Ritmo constante
        800, 400, 400, 400, 400, 400, 400, 800    // Ritmo constante
    };

    for (int i = 0; i < sizeof(notes) / sizeof(notes[0]); i++) {
        beep(durations[i], notes[i]);
        sleep_ms(50);  // Pequena pausa entre as notas
    }
}

// Função para tocar a música de boas-vindas
void play_good_night() {
  // Frequências das notas (em Hz)
  int notes[] = {
      523, 587, 659, 698, 784,  // Dó5, Ré5, Mi5, Fá5, Sol5
      698, 659, 587, 523,        // Fá5, Mi5, Ré5, Dó5
      587, 659, 698, 784,        // Ré5, Mi5, Fá5, Sol5
      698, 659, 587, 523,        // Fá5, Mi5, Ré5, Dó5
      587, 659, 698, 784,        // Ré5, Mi5, Fá5, Sol5
      698, 659, 587, 523         // Fá5, Mi5, Ré5, Dó5
  };

  // Duração de cada nota (em milissegundos)
  int durations[] = {
       400, 400, 400, 400, 800,  // 1 batida = 400 ms, 2 batidas = 800 ms
       800, 400, 400, 400,       // 2 batidas, 1 batida, 1 batida, 1 batida
       400, 400, 400, 800,       // 1 batida, 1 batida, 1 batida, 2 batidas
       800, 400, 400, 400,       // 2 batidas, 1 batida, 1 batida, 1 batida
       400, 400, 400, 800,       // 1 batida, 1 batida, 1 batida, 2 batidas
       800, 400, 400, 1600       // 2 batidas, 1 batida, 1 batida, 4 batidas
  };

  // Toca cada nota da música
  for (int i = 0; i < sizeof(notes) / sizeof(notes[0]); i++) {
      beep(durations[i], notes[i]);  // Toca a nota com a duração e frequência corretas
      sleep_ms(50);  // Pequena pausa entre as notas
  }
}


// Função para ler o estado do joystick

// Variáveis globais para debounce
uint32_t last_js_press_time = 0;
#define DEBOUNCE_DELAY_MS 200


// Função para ler o estado do joystick
JoystickState read_joystick() {
   // Leitura do joystick
   adc_select_input(0);
   int x_raw = adc_read();
   adc_select_input(1);
   int y_raw = adc_read();
   bool button_pressed = !gpio_get(22); // Pino 22


   // Debounce do botão
   uint32_t now = to_ms_since_boot(get_absolute_time());
   if (button_pressed && (now - last_js_press_time) > DEBOUNCE_DELAY_MS) {
       last_js_press_time = now;
       return JS_PRESS;
   }

    // Leitura das direções (sem debounce, pois são analógicas)
    if (x_raw < 100) return JS_LEFT;
    if (x_raw > 3000) return JS_RIGHT;
    if (y_raw < 100) return JS_UP;
    if (y_raw > 3000) return JS_DOWN;

    return JS_NEUTRAL;
}

// Função para atualizar o display OLED
void updateDisplay(uint8_t *buffer, int timeLeft) {
    char text[16];
    memset(buffer, 0, ssd1306_buffer_length);

    if (in_settings) {
        snprintf(text, sizeof(text), "%sStudy: %2d min",
                selected_setting == 0 ? ">" : " ", study_time / 60);
        ssd1306_draw_string(buffer, 5, 0, text);

        snprintf(text, sizeof(text), "%sBreak: %2d min",
                selected_setting == 1 ? ">" : " ", break_time / 60);
        ssd1306_draw_string(buffer, 5, 16, text);

        ssd1306_draw_string(buffer, 5, 32, "Press to confirm");
    } else {
        snprintf(text, sizeof(text), "Modo: %s", isStudying ? "Estudo" : "Descanso");
        ssd1306_draw_string(buffer, 5, 0, text);

        snprintf(text, sizeof(text), "Tempo: %02d:%02d", timeLeft / 60, timeLeft % 60);
        ssd1306_draw_string(buffer, 5, 16, text);

        snprintf(text, sizeof(text), "Tarefas: %d", tasksCompleted);
        ssd1306_draw_string(buffer, 5, 32, text);
    }

    struct render_area frame_area = {
        start_column: 0,
        end_column: ssd1306_width - 1,
        start_page: 0,
        end_page: ssd1306_n_pages - 1
    };
    calculate_render_area_buffer_length(&frame_area);
    render_on_display(buffer, &frame_area);
}

// Função para registrar tarefas concluídas
void registerTask() {
    tasksCompleted++;
    if (tasksCompleted >= 5) {  // Alto desempenho
        gpio_put(LED_GREEN_PIN, 1);
        gpio_put(LED_BLUE_PIN, 0);
        gpio_put(LED_RED_PIN, 0);
    } else if (tasksCompleted >= 3) {  // Médio desempenho
        gpio_put(LED_GREEN_PIN, 0);
        gpio_put(LED_BLUE_PIN, 1);
        gpio_put(LED_RED_PIN, 0);
    } else {  // Baixo desempenho
        gpio_put(LED_GREEN_PIN, 0);
        gpio_put(LED_BLUE_PIN, 0);
        gpio_put(LED_RED_PIN, 1);
    }
}

// Função principal
int main() {
    stdio_init_all();

    // Inicialização do ADC para o joystick
    adc_init();
    adc_gpio_init(JOYSTICK_X_PIN);
    adc_gpio_init(JOYSTICK_Y_PIN);
    gpio_init(JOYSTICK_BUTTON_PIN);
    gpio_set_dir(JOYSTICK_BUTTON_PIN, GPIO_IN);
    gpio_pull_up(JOYSTICK_BUTTON_PIN);

    // Inicialização do i2c
    i2c_init(i2c1, ssd1306_i2c_clock * 1000);
    gpio_set_function(I2C_SDA, GPIO_FUNC_I2C);
    gpio_set_function(I2C_SCL, GPIO_FUNC_I2C);
    gpio_pull_up(I2C_SDA);
    gpio_pull_up(I2C_SCL);

     // Inicialização do display OLED
   ssd1306_t ssd_bm;
   ssd1306_init_bm(&ssd_bm, 128, 64, false, 0x3C, i2c1);
   ssd1306_config(&ssd_bm);


   // Exibe o bitmap no display por 3 segundos e toca a música
   ssd1306_draw_bitmap(&ssd_bm, bitmap_128x64);
   play_good_night();  // Toca a música enquanto o bitmap é exibido
   sleep_ms(3000);  // Aguarda 3 segundos


   // Reconfigura o display para o modo de exibição do FocusBit
   ssd1306_init();  // Reinicializa o display para o modo padrão

    // Configuração dos botões
    gpio_init(BUTTON_1_PIN);
    gpio_set_dir(BUTTON_1_PIN, GPIO_IN);
    gpio_pull_up(BUTTON_1_PIN);

    gpio_init(BUTTON_2_PIN);
    gpio_set_dir(BUTTON_2_PIN, GPIO_IN);
    gpio_pull_up(BUTTON_2_PIN);

    // Configuração do buzzer
    gpio_init(BUZZER_PIN);
    gpio_set_dir(BUZZER_PIN, GPIO_OUT);

    // Configuração dos LEDs
    gpio_init(LED_GREEN_PIN);
    gpio_set_dir(LED_GREEN_PIN, GPIO_OUT);
    gpio_init(LED_BLUE_PIN);
    gpio_set_dir(LED_BLUE_PIN, GPIO_OUT);
    gpio_init(LED_RED_PIN);
    gpio_set_dir(LED_RED_PIN, GPIO_OUT);

    // Inicialização do buffer do display
    uint8_t ssd[ssd1306_buffer_length];
    memset(ssd, 0, ssd1306_buffer_length);

    // Inicialização do tempo
    timeLeft = study_time;

    // Loop principal
   while (true) {
       JoystickState js = read_joystick();


       if (in_settings) {
           // Lógica de ajuste de tempos
           switch (js) {
   case JS_UP:
       if (selected_setting == 0) study_time += 60;
       else break_time += 60;
       break;
   case JS_DOWN:
       if (selected_setting == 0 && study_time > 60) study_time -= 60;
       else if (break_time > 60) break_time -= 60;
       break;
   case JS_RIGHT:
   case JS_LEFT:
       selected_setting = !selected_setting;
       break;
               case JS_PRESS:
                   in_settings = false;
                   timeLeft = isStudying ? study_time : break_time;
                   break;
               default:
                   break;
           }
           sleep_ms(200);
       } else {
           // Lógica original do temporizador
           if (js == JS_PRESS) {
               in_settings = true;
               sleep_ms(200);
           }


           if (!gpio_get(BUTTON_1_PIN)) {
               isStudying = !isStudying;
               timeLeft = isStudying ? study_time : break_time;
               sleep_ms(500);
           }


           if (!gpio_get(BUTTON_2_PIN)) {
               registerTask();
               sleep_ms(500);
           }


           if (timeLeft > 0) {
               sleep_ms(1000);
               timeLeft--;
           }


           if (timeLeft == 0) {
               isStudying = !isStudying;
               timeLeft = isStudying ? study_time : break_time;

                // Toca a melodia correspondente ao modo que acabou
                if (isStudying) {
                    play_break_end_melody();  // Descanso acabou
                } else {
                    play_study_end_melody();  // Estudo acabou
                }
            }
        }

        // Atualiza o display
        updateDisplay(ssd, timeLeft);
    }

    return 0;
}